Introduction
	UIZE provides a system for automating various processes relating to the localization of a codebase.

	Localization as a Service
		UIZE exposes localization automation processes through a service, whose interface is defined in the =Uize.Services.Loc= abstract class.

		The =Uize.Services.Loc= service module defines the following `localization service methods`...

		- =metrics= - generates a `metrics report` for the `primary language` resource strings of a project
		- =export= - gathers strings from `codebase resource files` and exports them to `consolidated language resources files`, for each of the project's `supported languages`
		- =import= - distributes strings from the `consolidated language resources files` to `codebase resource files`, for each of the project's `supported languages`
		- =exportJobs= - exports `translation job files` from the `consolidated language resources files`, for each of the project's `translatable languages`
		- =importJobs= - imports translated strings from `translation job files` and merges them into the `consolidated language resources files`, for each of the project's `translatable languages`
		- =usage= - generates a `usage report` that contains details about usage of resource strings throughout a project, including information about unreferenced resource strings
		- =extract= - extracts strings from the project's codebase and generates `codebase resource files` for the project's `primary language` (may not be supported for a project)

		Localization Service Adapter
			As a convenience, UIZE provides an adapter base class for the =Uize.Services.Loc= service that can be applied, with some protected method overrides and configuration, to a variety of different types of projects.

			While it is possible to implement any adapter for the localization service, in reality there are sufficient commonalities between many different types of projects, such that it is beneficial to share implementation for the service adapter across as many different types of projects as possible. This is where the =Uize.Services.LocAdapter= module comes in. This module can be subclassed to create adapters for the localization service for different types of projects with minimal additional project type specific code needed.

	Accessed Through a Build Script
		The various `localization service methods` can be accessed using the =Uize.Build.Loc= build script.

		Running the Build Script
			The localization build script can be run in NodeJS using the following command...

			SYNTAX
			..................................................................................
			node [pathToUize]build.js Uize.Build.Loc project=[projectName] method=[methodName]
			..................................................................................

			Parameters
				project
					The =project= parameter is used to specify the project for which the specified `localization service method` should be executed.

					The value specified for the =project= parameter should match one of the keys in the =moduleConfigs ['Uize.Build.Loc'].projects= object of the =uize-config.json= file.

					Executing a Method For All Projects
						To execute a `localization service method` for all projects listed in the config, one can either omit the =project= parameter or one can specify the special "*" wildcard value.

						EXAMPLES
						......................................................................
						node [pathToUize]build.js Uize.Build.Loc method=[methodName]
						node [pathToUize]build.js Uize.Build.Loc project=* method=[methodName]
						......................................................................

				method
					The =method= parameter is used to specify the `localization service method` that should be executed for the specified project.

					The value of the =method= parameter should be the name of any of the `localization service methods` supported by the localization service, such as...

					- =metrics=
					- =export=
					- =import=
					- =exportJobs=
					- =importJobs=
					- =usage=
					- =extract=

				console
					The =console= parameter is used to specify the amount of information that should be logged to the console while the `localization service method` is being executed.

					The =console= parameter supports the following possible values...

					- =silent= - no information will be logged to the console
					- =summary= - only a summary will be logged to the console once execution of the `localization service method` is complete
					- =verbose= - information will be logged to the console for every step that is performed while the `localization service method` is being executed

### Project ~~ Projects
	.

### Languages
	Primary Language
		.

	Supported Languages
		.

	Translatable Languages
		.

### Key Features
	.

	Supports Multiple Projects
		.

	Adaptable to Different Project Types
		.

	Performs Diffing to Reduce Translation Load
		.

	Performs Automatic Pseudo-localization
		.

Localization Service Methods ~~ Localization Service Method
	The =Uize.Services.Loc= service module defines a number of different localization service methods.

	metrics
		Generates a metrics report for a project using the =metrics= method of the localization service.

		.............................................................................
		node [pathToUize]build.js Uize.Build.Loc project=[projectName] method=metrics
		.............................................................................

		Generates a Strings Metrics File
			The metrics method analyzes the resource strings for the project's `primary language` and generates a JSON format metrics file with the path...

			..............................................
			[workingFolder]/metrics/[primaryLanguage].json
			..............................................

			Using this scheme, if the value of the =workingFolder= config option is ='loc'=, and the value of the =primaryLanguage= config option is ='en-US'=, then the path for the metrics file would be...

			......................
			loc/metrics/en-US.json
			......................

		Generates Strings Info Files
			In addition to generating the strings metrics JSON file, the =metrics= method also generates JSON and CSV format `strings info files` for the primary language.

			These files are output to the following paths...

			...................................................
			[workingFolder]/strings-info/[primaryLanguage].csv
			[workingFolder]/strings-info/[primaryLanguage].json
			...................................................

			Using this scheme, if the value of the =workingFolder= config option is ='loc'=, and the value of the =primaryLanguage= config option is ='en-US'=, then the paths for the strings info files would be...

			...........................
			loc/strings-info/en-US.csv
			loc/strings-info/en-US.json
			...........................

	export
		Exports the resource strings from the `codebase resource files` of a project to the `master resource files`.

		............................................................................
		node [pathToUize]build.js Uize.Build.Loc project=[projectName] method=export
		............................................................................

		The `master resource files` are output to the following paths...

		............................................
		[workingFolder]/[primaryLanguage].json
		[workingFolder]/[pseudoLocale].json
		[workingFolder]/[translatableLanguage1].json
		[workingFolder]/[translatableLanguage2].json
		... ... ... ... ... ... ... ... ... ... ...
		[workingFolder]/[translatableLanguageN].json
		............................................

		EXAMPLE
		..............
		loc/en-US.json
		loc/en-ZZ.json
		loc/en-GB.json
		loc/fr-FR.json
		loc/de-DE.json
		..............

		In the above example, the =workingFolder= config option is set to ='loc'=, the =primaryLanguage= config option is set to ='en-US'=, the =pseudoLocale= config option is set to ='en-ZZ'=, and the configured translatable languages are ='en-GB'= (English for Great Britain), ='fr-FR'= (French), and ='de-DE'= (German).

		Initializing Values of Non-translatable Strings
			The values of the non-translatable strings of a project can be initialized by executing the =export= command and specifying one of the supported initialization modes using the =initNonTranslatable= parameter.

			...........................................................................................................
			node [pathToUize]build.js Uize.Build.Loc project=[projectName] method=export initNonTranslatable=[initMode]
			...........................................................................................................

			initNonTranslatable
				By default, the value for each non-translatable string is initialized to the corresponding value of the string from the primary language, but only if the non-translatable string is currently blank.

				If this behavior is not suitable, one of the other available initialization modes can be specified using the =initNonTranslatable= parameter. The following initialization modes are supported...

				- =primary-if-blank= (default) - initializes the values of only blank non-translatable strings to the corresponding values of the strings from the primary language
				- =primary= - initializes the values of all non-translatable strings to the corresponding values of the strings from the primary language, regardless of their current values
				- =blank= - initializes the values of all non-translatable strings to blank (empty string), regardless of their current values
				- =never= - leaves the values of all non-translatable strings as is, keeping their current values

	import
		Imports the resource strings from the `master resource files` of a project back into the `codebase resource files`.

		............................................................................
		node [pathToUize]build.js Uize.Build.Loc project=[projectName] method=import
		............................................................................

		Executing the =import= method will have the effect of overwriting all the `codebase resource files` for the pseudo-locale and the translatable languages so that their contents reflects the contents of the `master resource files`. The =import= method will also create new codebase resource files, as necessary, if they did not previously exist.

	exportJobs
		Exports resource strings for translation from the `master resource files` of a project to `translation job files`.

		................................................................................
		node [pathToUize]build.js Uize.Build.Loc project=[projectName] method=exportJobs
		................................................................................

		Export Filters
			The =exportJobs= method supports the ability to filter the strings that are exported to the translation job files, using the optional =filter= paramter.

			....................................................................................................
			node [pathToUize]build.js Uize.Build.Loc project=[projectName] method=exportJobs filter=[filterName]
			....................................................................................................

			filterName
				The localization service adapter base class supports the following filters for the =exportJobs= method...

				- =missing= (defualt) -
				- =translated= -
				- =all= -

		Export Format
			.

		###
			- for all translatable languages - excludes primary language and pseudo-locale
			- only the strings for which translation is needed
			- file format

			- make sure `master resource files` are up-to-date before executing the =exportJobs= method by first executing the =export= method

	importJobs
		.

		................................................................................
		node [pathToUize]build.js Uize.Build.Loc project=[projectName] method=importJobs
		................................................................................

	usage
		.

		...........................................................................
		node [pathToUize]build.js Uize.Build.Loc project=[projectName] method=usage
		...........................................................................

	extract
		.

		.............................................................................
		node [pathToUize]build.js Uize.Build.Loc project=[projectName] method=extract
		.............................................................................

Configuring Projects
	The behavior of the =Uize.Build.Loc= build script is configurable to support one or more projects of potentially different types.

	`Config options` for the =Uize.Build.Loc= build script should be placed inside the =uize-config.json= config file, under the path =moduleConfigs ['Uize.Build.Loc']=, as illustrated by the example below...

	EXAMPLE
	..............................................................
	{
		// other config options
		// other config options
		// other config options
		// other config options

		moduleConfigs:{
			'Uize.Build.Loc':{
				workingFolder:'loc',
				projects:{
					Uize:{
						serviceAdapter:'Uize.Services.LocAdapter.Uize',
						rootFolderPath:'site-source/js',
						languages:[
							'en-US',
							'de-DE',
							'fr-FR',
							'ja-JP',
							'nl-NL',
							'ru-RU',
							'zh-CN'
						],
						primaryLanguage:'en-US',
						pseudoLocale:'en-ZZ'
					}
				}
			}
		}
	}
	..............................................................

	The above example shows the configuration of the =Uize.Build.Loc= build script for the UIZE project.

	Config Options
		The =Uize.Build.Loc= build script supports a number of configuration options.

		Working Folder ~~ workingFolder
			The =workingFolder= config option specifies the path, relative to the current working directory, to the working folder for the =Uize.Build.Loc= build script.

			The working folder is used to store the output of the various `localization service methods`.

		Per Project Configuration Options
			.

			Service Adapter ~~ serviceAdapter
				.

			Root Folder Path ~~ rootFolderPath
				.

			Languages ~~ languages
				.

			Brand Languages ~~ brandLanguages
				.

			Primary Language ~~ primaryLanguage
				.

			Pseudo-locale ~~ pseudoLocale
				.

			Pseudo-localization ~~ pseudoLocalization
				.

			Translation Job File Format ~~ translationJobFileFormat
				.

				- =csv= -
				- =xliff= -

		Common Project Configuration Options ~~ common
			.

Localization Service Workflows
	Performing Translation
		In order to have the resource strings for a project be translated, one must first `export the resource strings for translation` and then `import the translated resource strings`.

		Export the Resource Strings for Translation
			Exporting the resource strings for translation for a project involves the following steps...

			+. Execute the =export= `localization service method` to update the =.json= `master resource files` to reflect the current state of the `codebase resource files`.
			+. Execute the =exportJobs= `localization service method` to generate updated `translation job files`.

			Once the `translation job files` have been generated to reflect the current state of the project's codebase and the strings that actually need translation, these files can be sent to translators for translation.

		Import the Translated Resource Strings
			Once the translation job files have been processed by the translators and the strings have been translated, the translations can be imported back into the project's codebase with the following steps...

			+. Replace the `translation job files` inside the *jobs* folder with the updated files delivered by the trabslators.
			+. Execute the =importJobs= `localization service method` to update the =.json= `master resource files` with the translations contained inside the `translation job files`.
			+. Execute the =import= `localization service method` to update the `codebase resource files` of the project with the strings from the updated =.json= `master resource files`.

			Once the `codebase resource files` have been updated, a diff sanity check in one's source control tool should verify that the translations have made their way into the resource files in the project's codebase.

	Changes to Resource Strings
		Deleting Resource Strings
			At times, it will be necessary to delete one or more resource strings because a component has been modified.

			Consider that the application may support multiple different languages and there may be translations in the resource files for different languages for the resource strings you wish to delete. With the Loc service, it is not necessary to remove the resource strings from the translated resource files - they will be repaired if you follow these steps...

			+. Delete the resource strings in the primary language resource files. Be sure to remove all brand-specific overrides, if any exist, from the primary language resource files.
			+. Execute the =export= method of the Loc service to update the =.json= `master resource files`.
			+. Execute the =import= method of the Loc service to re-generate the resource files for the supported languages of the project.

			Performing the =export= followed by the =import= will have the effect of repairing the resource files in the codebase so that the removed resource strings will no longer exist in the resource files for the supported languages.

		### Modifying Resource Strings
			.

		### Adding Resource Strings
			.

		Renaming Resource Strings
			At times, it will be necessary to rename one or more resource strings because a component has been modified.

			Consider that the application may support multiple different languages and there may be translations in the resource files for different languages for the resource strings you wish to rename. The Loc service does not provide any special handling for such situations and you will need to rename the resource strings in the resource files for the primary language and all other supported languages.

		### Re-translating Resource Strings
			.

	### Changes to Resource Files
		Deleting Resource Files
			.

		Adding Resource Files
			.

	### Changes to Language Support
		Adding Support for a New Language
			.

		Removing Support for a Language
			.

	### Changes in Projects
		Adding a New Project
			.

		Branching a Project
			.

	Localization Loop

		..................................................................................................
		            -------> 4. translate jobs -------> -------> 9. translate jobs -------> ----------->
		            ∧                                 | ∧                                 | ∧
		            |                                 | |                                 | |
		            | 3. export             5. import | | 8. export            10. import | | 13. export
		            |    jobs                  jobs   | |    jobs                  jobs   | |     jobs
		            |                                 ∨ |                                 ∨ |
		    |-------------------------------------------------------------------------------------|
		    |                                                                                     |
		    |                               MASTER RESOURCE FILES                                 |
		    |                                                                                     |
		    |-------------------------------------------------------------------------------------|
		          ∧ |                                 ∧ |                                 ∧ |
		          | |                                 | |                                 | |
		1. export | | 2. import             6. export ! | 7. import            11. export ! | 12. import
		          ! |                                 ! |                                 ! |
		          ! ∨                                 ! ∨                                 ! ∨
		|---------------------------------------------------------------------------------------------|
		|        |   |                               |   |                               |   |        |
		|        | A |  ------> 4. develop ------->  | B |  ------> 9. develop ------->  | C |        |
		|        |   |                               |   |                               |   |        |
		|---------------------------------------------------------------------------------------------|
		..................................................................................................

		+. `export`
		+. `import`
		+. `export jobs`
		+. `translate jobs` and `develop`
		+. `import jobs`
		+. `export`
		+. `import`
		+. `repeat from step 3`


	### Iterative Translation
		revision A
			- initiate translations
				export
				exportJobs
					- XLIFF files for translatable languages will have entries for only strings that are empty (the delta)

		revision B
			- one string was added
			- one string was removed
			- one string was changed
			- .json mater file should reflect state of codebase at revision A
			- importJobs
			- import
				- resource files for primary language are not modified
			- after import, codebase resource files for translatable languages will contain...
				- no string for string that was added since revision A
				- the old translations for the string that was removed since revision A
				- the old translations for the string that was changed since revision A
			- repair, using export + import
			- after repair...
				- there will be an empty string value for the string that was added since revision A
				- translations for string that was removed since revision A will be gone
				- the defunct translations for the string that was changed since revision A will be blanked out

			- initiate translations
				export
				exportJobs
					- XLIFF files for translatable languages will have entries for...
						- strings that were added since revision A
						- strings that were changed since revision A

Advanced Topics
	Non-translatable Strings
		Non-translatable strings are strings that should never be pseudo-localized and should never be sent to translators for translation.

		Examples of non-translatable resource strings would be...

		- URLs
		- media asset IDs
		- dimension values
		- color values
		- support e-mail addresses or phone numbers
		- item codes

		Reasons for Treating Some Strings as Non-translatable
			There are good reasons to identify certain strings as being non-translatable and then handle such strings differently in the automation process.

			A Waste of Money
				For one thing, it is a waste of money to send non-translatable strings to translators.

				Translators will likely not know what to do with such strings, and determining how to handle them may involve some costly back-and-forth communication between the project managers on both sides of the process. And if they actually translate such strings by accident, then they will charge for that translation work.

			Breakage from Accidental Translation
				Accidental translation of strings that should not be translated can result in breakage of the application.

				For example, a resource string may be used for storing a color value that should be different per language. Technologies such as CSS support named color values, such as "red" or "green". If the intention is to use the color red for one language and the color green for another language, it is not helpful if the actual text "red" is translated to some other language by the translators. Translating "red" to "rouge" in French would break the application in that the translated color value would not be recognized by CSS.

				Instead, such a string should be treated as a non-translatable string, and it would then be the responsibility of a developer to manually change the value in the resource files of the translatable languages, under the direction of a product manager who makes the decision what colors best suit different language audiences.

			Breakage from Pseudo-localization
				Accidental pseudo-localization of some non-translatable strings (such as IDs or URLs) may break the pseudo-localized version of the application and hinder localization QA testing of the pseudo-localized version.

				For example, if a resource string was being used to store a code like ="AdvancedMode"=, where this code is being used by the application logic and is intended to be different per language, then pseudo-localizing the value from the primary language to ="[ÅðṽåñçéðṀöðé____]"= would break the application as it would not understand this value.

		Non-translatable Strings Vary by Project
			Different types of projects will likely have different varieties of non-translatable strings that it is convenient for the project to store in `codebase resource files`.

			Therefore, it is up to each project to determine which strings are translatable and which strings are not. This is accomplished by implementing an override to the new =isTranslatableString= method in the `localization service adapter`.

			isTranslatableString
				Implementing support for non-translatable strings in a project involves providing an implementation for the =isTranslatableString= instance method in the localization adapter subclass for the project.

				The implementation in the adapter base class just returns =true=, so all resource strings are considered translatable by default.

				An implementation for the =isTranslatableString= method should expect to receive a single argument, being a string info object that describes a resource string. The string info object will contain a =key= property that specifies the resource string's key name, along with a =value= property that specifies the value of the resource string for the `primary language`.

				The method implementation should use the information in the string info object to determine a boolean return value, indicating whether or not the string is translatable. The implementation can use either or both of the =key= and =value= properties to reach its determination- whichever is best suited to the nature of the resource strings in the project.

				EXAMPLE
				..................................................................................
				function (stringInfo) {
					return (
						!/_(ID|EMAIL)$/.test (stringInfo.key) &&  // it's an ID or an e-mail address
						!/^https?:\/\//.test (stringInfo.value)   // it's a URL
					);
				}
				..................................................................................

				In the above example implementation for the =isTranslatableString= method, the method is first performing a test on the key of the resource string, checking to see if it ends with "_ID" or "_EMAIL". If this test fails, the method is then testing if the value of the resource string starts with "http://" or "https://".

			Establish a Convention for Non-translatable Strings
				While it is possible to write complex matching logic to test whether or not resource strings should be translatable, it is recommended that projects establish a simple and robust convention.

				For example, a project could follow the convention that all non-translatable resource strings are indicated with a specific suffix or prefix in their key names. For instance, all non-translatable resource strings could have a "$" character appended to their key names.

				EXAMPLE
				............................................................
				function (stringInfo) {
					// string is translatable if its key doesn't end with "$"
					return stringInfo.key.slice (-1) != '$';
				}
				............................................................

				Following such a convention would provide the following benefits...

				- it becomes clear from the `codebase resource files` exactly which strings are not to be translated
				- the =isTranslatableString= test is simple, robust, and highly performant
				- it is easy to add new non-translatable strings of different types later to a project later, without needing to update the implementation of the =isTranslatableString= method

			Surveying Non-translatable Strings
				In order to verify that one's implementation of the =isTranslatableString= method for a project is doing the right thing, you can survey the strings that are determined to be non-translatable by using the =metrics= localization service method.

				When you execute the =metrics= method, one of its by-products will be the strings info files that are written to the "strings-info" folder. The strings info is obtained from the resource strings in the primary language resource files for the project and is written to two different format files: one JSON format file, and one CSV format file.

				- *.json* - The JSON format file contains an array of string info objects for all of the strings of the project, where each string info object contains properties such as =path=, =value=, =isTranslatable=, etc., and where the values for some properties (such as the =metrics= property) are sub-objects.
				- *.csv* - The CSV format file contains a table of rows for all of the strings of the project, where each row contains a number of columns that represent a flattened version of the string info object for a string.

				Both of these two strings info files contain the same information, but expressed slightly differently. The CSV file is particularly easy to "consume" and can be loaded up in any spreadsheet editor (such as Google Sheets) that correctly supports the CSV format's ability to have quoted field values that contain line breaks (some of your resource strings may contain line break characters).

				Once loaded into a spreadsheet tool, the =Translatable= column can be used to sort or filter the strings info rows based upon whether or not the strings are considered translatable. For non-translatable strings, the value in the =Translatable= column will be =false=. The spreadsheet can then be used to verify that there are no non-translatable strings being missed by the =isTranslatableString= method, and there are no translatable strings that are being incorrectly caught by it.

		Handling of Non-translatable Strings
			Non-translatable strings are handled according to the following rules...

			Never Pseudo-localized
				Non-translatable strings are never pseudo-localized when resource strings for the pseudo-locale are generated by the =export= localization service method.

				Instead, the values from the primary language will be used as is.

			Never Exported for Translation
				Non-translatable strings are never exported to `translation job files` by the =exportJobs= localization service method.

				This means that translators never have to deal with these strings, and there's never a possibility that translators will accidentally translate them, resulting in charges for wasted effort or even problems for the application.

			Initialized to Primary Language Values
				Whenever a non-translatable string is added or modified for the primary language of a project, the values for the string for the translatable languages are initialized to the value from the primary language.

				In this way, the values for the string in the resource files for the translatable languages don't need to be manually initialized by developers.

			Manually Modified Values are Respected
				While the values for non-translatable strings are `initialized to primary language values`, the values for the strings in the translatable languages can subsequently be manually modified by developers.

				Non-empty values for non-translatable strings in the resource files for the translatable languages of a project are respected throughout the localization automation process.

	Metrics Reports ~~ Metrics Report
		A metrics report can be produced for a project by using the =metrics= `localization service method`.

		EXAMPLE
		.............................................................................
		node [pathToUize]build.js Uize.Build.Loc project=[projectName] method=metrics
		.............................................................................

		The =metrics= method analyzes the primary language resource strings for a porject and generates a =.json= file to the following path...

		............................................................
		[workingFolder]/[projectName]/metrics/[primaryLanguage].json
		............................................................

		The metrics report is a JSON file, so the data contained in it could be loaded by other scripts or an application and used to present a visualization of the metrics or to estimate cost for translation.

		Metrics Report Contents
			Total Word Count
				The total number of translatable words in all primary language resource files for the project is represented by the =resourceFiles= property.

				The value of the =wordCount= property is only an estimate and the accuracy of the value depends on how well the project is defined to understand the difference between `translatable words` and `non-translatable text`.

				The value of this property is useful when estimating the full translation cost for a project, since translators often charge for their services based upon word count and a cost per word.

			Total Character Count
				The total number of translatable words in all primary language resource files for the project is represented by the =resourceFiles= property.

				The accuracy of the value of this property depends on the accuracy of the =wordCount= property, since this property is the sum of the character count for all `translatable words`. This value can be useful when estimating the full translation cost for a project, since translators may base cost estimates for their services partially upon total character count for all `translatable words`.

			Total Resource Files
				The total number of resource files for the language is represented by the =resourceFiles= property.

				The value of the =resourceFiles= property reflects the total number of codebase resource files for the language and not the total for all languages, so this value doesn't increase as you add support for new languages.

			Brand-specific Resource Files
				The total number of brand-specific resource files for the language is represented by the =brandSpecificResourceFiles= property.

				What constitutes a brand-specific resource file will vary by project and depend on the project definition. Typically, brand-specific resource files provide overrides for certain resource strings that need to be different for specific brands, so the number of brand-specific resource files is usually smaller than the total number of resource files. Moreover, different brands may have a differing number of brand-specific resource files.

	### Different Classes of Files
		Codebase Resource Files
			.

		Master Resource Files
			.

		Translation Job Files
			.

		Strings Metrics Files
			.

		Strings Info Files
			.

### Use With Other Projects
	.

### Key Concepts
	Translatable Words
		.

	Non-translatable Text
		.

