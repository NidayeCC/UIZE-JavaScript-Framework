Introduction
	The UIZE JavaScript Framework implements a system for class inheritance that makes subclassing and object-oriented programming possible in JavaScript.

Creating Classes
	UIZE's system for classes and inheritance makes it dead easy to create a class.

	Class features are provided in the =Uize.Class= module. You can create your own class very easily, simply by calling the =subclass= method on the =Uize.Class= base class, as follows...

	.....................................
	var MyCkass = Uize.Class.subclass ();
	.....................................

	Creating Further Subclasses
		All subclasses that inherit from =Uize.Class= get a =subclass= static method, so you can make further subclasses just as easily...

		...........................................................
		var MyClass = Uize.Class.subclass ({
			instanceMethods:{
				fooMethod:function () {
					alert ('foo');
				},
				barMethod:function () {
					alert ('bar');
				}
			}
		});

		var MySubclass = MyClass.subclass ({
			instanceMethods:{
				barMethod:function () {
					alert ('overridden bar');
				}
			}
		});

		var mySubclassInstance = new MySubclass ();
		mySubclassInstance.fooMethod ();  // alerts "foo"
		mySubclassInstance.barMethod ();  // alerts "overriden bar"
		...........................................................

Declaring Features
	For convenience, UIZE provides a few different ways of declaring a class' features to suit different situations.

	Declaring Features During Class Creation
		The most concise form of declaring class features allows the features to be optionally declared in the call to the =subclass= method.

		.......................................
		var MyClass = Uize.Class.subclass ({
			instanceMethods:{
				someInstanceMethod1:function () {
					// do some stuff
				},
				someInstanceMethod2:function () {
					// do some stuff
				}
			},
			staticMethods:{
				someStaticMethod1:function () {
					// do some stuff
				},
				someStaticMethod2:function () {
					// do some stuff
				}
			}
		});
		.......................................

		The =Uize.Class.subclass= method can optionally accept a =featuresByTypeOBJ= parameter, whose value should be a `features declaration object`, where the name of each property should be the name of a `feature type`, and where the value of each property should be an object containing any number of features of that type.

	Using the declare Static Method
		If you already have a reference to a created class and you would like to declare multiple features of different types in a single method call, you can call the =MyClass.declare= static on the class.

		.......................................
		MyClass.declare ({
			instanceMethods:{
				someInstanceMethod1:function () {
					// do some stuff
				},
				someInstanceMethod2:function () {
					// do some stuff
				}
			},
			staticMethods:{
				someStaticMethod1:function () {
					// do some stuff
				},
				someStaticMethod2:function () {
					// do some stuff
				}
			}
		});
		.......................................

	Using the Feature Declaration Methods
		As an alternative to using the =MyClass.declare= static method, you can declare features on a class using the various feature declaration static methods of the class that are inherited from the =Uize.Class= base class.

		- call the =MyClass.instanceMethods= method to declare instance methods
		- call the =MyClass.staticMethods= method to declare static methods
		- call the =MyClass.stateProperties= method to declare state properties
		- more feature declaration methods: =MyClass.instanceProperties=, =MyClass.staticProperties=, etc.

		EXAMPLE
		....................................
		MyClass.instanceMethods ({
			someInstanceMethod1:function () {
				// do some stuff
			},
			someInstanceMethod2:function () {
				// do some stuff
			}
		});

		MyClass.staticMethods ({
			someStaticMethod1:function () {
				// do some stuff
			},
			someStaticMethod2:function () {
				// do some stuff
			}
		});
		....................................

	Modifying the Class Manually
		In addition to the various convenient ways that are provided for declaring class features, you can also declare features by modifying a class manually.

		- assign properties on the class' =prototype= object to define instance methods and/or properties
		- assign properties on the class to define static methods and/or properties

		EXAMPLE
		....................................................
		MyClass.prototype.someInstanceMethod = function () {
			// do some stuff
		};

		MyClass.someStaticMethod = function () {
			// do some stuff
		};
		....................................................

		While this technique is not recommended, you may encounter older UIZE code that uses this technique for declaring class features, since the code may not yet have been updated since the newer approach to feature declaration was introduced.

	Feature Declaration Methods
		The =Uize.Class= module provides a number of methods that let you declare instance and/or static features of a class.

		- =Uize.Class.declare= - lets you declare one or more features of one or more different `feature types` for the class
		- =Uize.Class.alphastructor= - lets you declare the `alphastructor` for the class
		- =Uize.Class.omegastructor= - lets you declare the `omegastructor` for the class
		- =Uize.Class.instanceMethods= - lets you declare one or more `instance methods` for the class
		- =Uize.Class.instanceProperties= - lets you declare one or more `instance properties` for the class
		- =Uize.Class.staticMethods= - lets you declare one or more `static methods` for the class
		- =Uize.Class.staticProperties= - lets you declare one or more `static properties` for the class
		- =Uize.Class.dualContextMethods= - lets you declare one or more `dual context methods` for the class
		- =Uize.Class.dualContextProperties= - lets you declare one or more `dual context properties` for the class
		- =Uize.Class.stateProperties= - lets you declare one or more `state properties` for instances of the class

	Features Declaration Object ~~ featuresByTypeOBJ
		.

	Declare Private or Public Features
		The `feature declaration methods` can be used either to declare public features or private features.

		In UIZE, there is no fundamental difference between private methods or properties and public methods or properties - it's all in the naming. By convention, private features are named with an "_" (underscore) prefix. This has its pros and cons, but one side effect of this is that either private or public features (or a mixture of both) can be declared using the `feature declaration methods`.

		EXAMPLE
		........................................
		_class.instanceMethods ({
			_privateInstanceMethod1:function () {
				// implementation here
			},
			_privateInstanceMethod2:function () {
				// implementation here
			},
			publicInstanceMethod1:function () {
				// implementation here
			},
			publicInstanceMethod2:function () {
				// implementation here
			}
		});
		........................................

		In the above example, one call to the =Uize.Class.instanceMethods= method is being used to declare the =_privateInstanceMethod1= and =_privateInstanceMethod2= private instance methods, along with the =publicInstanceMethod1= and =publicInstanceMethod2= public instance methods.

		For a more in-depth discussion on implementing private features for a class, consult the section `Private vs. Public`.

	Feature Declarations are Cumulative
		All the `feature declaration methods` can be called as many times as desired, and calling them repeatedly is cumulative in nature.

		This is useful, because it lets you break out declarations into different sections in your code if that makes your code more readable and/or manageable.

		EXAMPLE
		........................................
		// Private Instance Methods
		_class.instanceMethods ({
			_privateInstanceMethod1:function () {
				// implementation here
			},
			_privateInstanceMethod2:function () {
				// implementation here
			}
		});

		// ... ... ... ... ... ... ... ... ...

		// Public Instance Methods
		_class.instanceMethods ({
			publicInstanceMethod1:function () {
				// implementation here
			},
			publicInstanceMethod2:function () {
				// implementation here
			}
		});
		........................................

		In the above example, the =Uize.Class.instanceMethods= method is being called twice - in one section to declare private instance methods, and in the other section to declare public instance methods.

	Dual Context
		Dual context class features are features that exist both on the class as well as instances of the class.

		Examples of dual context features are the various event system methods. For example, the =fire= instance method lets you fire an instance event, while the =Uize.Class.fire= static method lets you fire an event on a class. Both the instance and class methods for firing events share the same underlying implementation, where the implementation may contain minor conditionalizing when executing in the instance context versus executing in the class context.

		In cases where it is possible (and possibly even desirable) to share the same function between an instance method and a class method, the =Uize.Class.dualContextMethods= static method can be used to declare such methods in a single statement, rather than separately calling both the =Uize.Class.instanceMethods= and =Uize.Class.staticMethods= methods.

		Although a less likely scenario, it is also possible to declare dual context properties using the =Uize.Class.dualContextProperties= static method. This method is present mainly for symmetry and consistency.

		For dual context features, it is assumed that the feature is named the same on both the instance and the class. In situations where this is not the case, one should just use the separate methods for defining instance features and class features.

Feature Types ~~ Feature Type ~~ Features
	The UIZE class system formally supports the following feature types...

	Alphastructor
		The alphastructor is a constructor in the `alphastructor chain` for a class that is executed before the `state properties` for the instance are initialized.

		When a subclass is created, the `alphastructor chain` for the class is created by copying the alphastructor chain of the superclass and then appending the alphastructor specified for the new subclass.

		The alphastructor can be declared for a class in any of the following ways...

		Declaring the Alphastructor During Subclassing
			The `alphastructor` can be declared for a class when the class is created, by using the optional =featuresByTypeOBJ= parameter when calling the =Uize.Class.subclass= static method.

			The `features declaration object` should contain an =alphastructor= property whose value should be the alphastructor function.

			EXAMPLE
			........................................
			var MyClass = Uize.Class.subclass ({
				alphastructor:function () {
					// implementation of alphastructor
				}
			});
			........................................

		Declaring the Alphastructor After Subclassing, Using MyClass.declare
			The `alphastructor` can be declared for a class after the class has already been created, by calling the =MyClass.declare= method on the class.

			The `features declaration object` passed to the =MyClass.declare= method should contain an =alphastructor= property whose value should be the alphastructor function.

			EXAMPLE
			........................................
			MyClass.declare ({
				alphastructor:function () {
					// implementation of alphastructor
				}
			});
			........................................

		Declaring the Alphastructor After Subclassing, Using MyClass.instanceMethods
			The `alphastructor` can be declared for a class after the class has already been created, by calling the =MyClass.alphastructor= method on the class.

			When calling the =MyClass.alphastructor= method, it should be passed a single function parameter that is the alphastructor function.

			EXAMPLE
			........................................
			MyClass.alphastructor (
				function () {
					// implementation of alphastructor
				}
			);
			........................................

	Omegastructor
		The omegastructor is a constructor in the `omegastructor chain` for a class that is executed after the `state properties` for the instance are initialized.

		When a subclass is created, the `omegastructor chain` for the class is created by copying the omegastructor chain of the superclass and then appending the omegastructor specified for the new subclass.

		The omegastructor can be declared for a class in any of the following ways...

		Declaring the Omegastructor During Subclassing
			The `omegastructor` can be declared for a class when the class is created, by using the optional =featuresByTypeOBJ= parameter when calling the =Uize.Class.subclass= static method.

			The `features declaration object` should contain an =omegastructor= property whose value should be the omegastructor function.

			EXAMPLE
			........................................
			var MyClass = Uize.Class.subclass ({
				omegastructor:function () {
					// implementation of omegastructor
				}
			});
			........................................

		Declaring the Omegastructor After Subclassing, Using MyClass.declare
			The `omegastructor` can be declared for a class after the class has already been created, by calling the =MyClass.declare= method on the class.

			The `features declaration object` passed to the =MyClass.declare= method should contain an =omegastructor= property whose value should be the omegastructor function.

			EXAMPLE
			........................................
			MyClass.declare ({
				omegastructor:function () {
					// implementation of omegastructor
				}
			});
			........................................

		Declaring the Omegastructor After Subclassing, Using MyClass.instanceMethods
			The `omegastructor` can be declared for a class after the class has already been created, by calling the =MyClass.omegastructor= method on the class.

			When calling the =MyClass.omegastructor= method, it should be passed a single function parameter that is the omegastructor function.

			EXAMPLE
			........................................
			MyClass.omegastructor (
				function () {
					// implementation of omegastructor
				}
			);
			........................................

	Instance Methods
		Instance methods are functions that are assigned on the =prototype= object of a class.

		When a subclass is created, all instance methods of the superclass are inherited by the subclass through a copy operation. Once a subclass is created, changing the inherited instance methods on the superclass has no effect on the subclass.

		Instance methods can be declared for a class in any of the following ways...

		Declaring Instance Methods During Subclassing
			Instance methods can be declared for a class when the class is created, by using the optional =featuresByTypeOBJ= parameter when calling the =Uize.Class.subclass= static method.

			The `features declaration object` should contain an =instanceMethods= property whose value should be an object containing mappings of instance method names to implementation functions.

			EXAMPLE
			.................................................
			var MyClass = Uize.Class.subclass ({
				instanceMethods:{
					foo:function () {
						// implementation of foo instance method
					},
					bar:function () {
						// implementation of bar instance method
					}
				}
			});
			.................................................

		Declaring Instance Methods After Subclassing, Using MyClass.declare
			Instance methods can be declared for a class after the class has already been created, by calling the =MyClass.declare= method on the class.

			The `features declaration object` passed to the =MyClass.declare= method should contain an =instanceMethods= property whose value should be an object containing mappings of instance method names to implementation functions.

			EXAMPLE
			.................................................
			MyClass.declare ({
				instanceMethods:{
					foo:function () {
						// implementation of foo instance method
					},
					bar:function () {
						// implementation of bar instance method
					}
				}
			});
			.................................................

		Declaring Instance Methods After Subclassing, Using MyClass.instanceMethods
			Instance methods can be declared for a class after the class has already been created, by calling the =MyClass.instanceMethods= method on the class.

			When calling the =MyClass.instanceMethods= method, an instance methods declaration object should be provided, containing instance method name to implementation function mappings.

			EXAMPLE
			..............................................
			MyClass.instanceMethods ({
				foo:function () {
					// implementation of foo instance method
				},
				bar:function () {
					// implementation of bar instance method
				}
			});
			..............................................

	Instance Properties
		Instance properties are non-function type values that are assigned on the =prototype= object of a class.

		When a subclass is created, all instance properties of the superclass are inherited by the subclass through a clone-copy operation. Once a subclass is created, changing the inherited instance properties on the superclass has no effect on the subclass.

		Instance properties can be declared for a class in any of the following ways...

		Declaring Instance Properties During Subclassing
			Instance properties can be declared for a class when the class is created, by using the optional =featuresByTypeOBJ= parameter when calling the =Uize.Class.subclass= static method.

			The `features declaration object` should contain an =instanceProperties= property whose value should be an object containing mappings of instance property names to initial values.

			EXAMPLE
			....................................
			var MyClass = Uize.Class.subclass ({
				instanceProperties:{
					foo:'bar',
					baz:'qux'
				}
			});
			....................................

		Declaring Instance Properties After Subclassing, Using MyClass.declare
			Instance properties can be declared for a class after the class has already been created, by calling the =MyClass.declare= method on the class.

			The `features declaration object` passed to the =MyClass.declare= method should contain an =instanceProperties= property whose value should be an object containing mappings of instance property names to initial values.

			EXAMPLE
			.......................
			MyClass.declare ({
				instanceProperties:{
					foo:'bar',
					baz:'qux'
				}
			});
			.......................

		Declaring Instance Properties After Subclassing, Using MyClass.instanceProperties
			Instance properties can be declared for a class after the class has already been created, by calling the =MyClass.instanceProperties= method on the class.

			When calling the =MyClass.instanceProperties= method, an instance properties declaration object should be provided, containing mappings of instance property names to initial values.

			EXAMPLE
			.............................
			MyClass.instanceProperties ({
				foo:'bar',
				baz:'qux'
			});
			.............................

	Static Methods
		Static methods are functions that are assigned on the class.

		When a subclass is created, all static methods of the superclass are inherited by the subclass through a copy operation (the exception to this is `non-inheritable statics` that are registered with `the MyClass.nonInheritableStatics static property`). Once a subclass is created, changing the inherited static methods on the superclass has no effect on the subclass.

		Static methods can be declared for a class in any of the following ways...

		Declaring Static Methods During Subclassing
			Static methods can be declared for a class when the class is created, by using the optional =featuresByTypeOBJ= parameter when calling the =Uize.Class.subclass= static method.

			The `features declaration object` should contain an =staticMethods= property whose value should be an object containing mappings of static method names to implementation functions.

			EXAMPLE
			...............................................
			var MyClass = Uize.Class.subclass ({
				staticMethods:{
					foo:function () {
						// implementation of foo static method
					},
					bar:function () {
						// implementation of bar static method
					}
				}
			});
			...............................................

		Declaring Static Methods After Subclassing, Using MyClass.declare
			Static methods can be declared for a class after the class has already been created, by calling the =MyClass.declare= method on the class.

			The `features declaration object` passed to the =MyClass.declare= method should contain an =staticMethods= property whose value should be an object containing mappings of static method names to implementation functions.

			EXAMPLE
			...............................................
			MyClass.declare ({
				staticMethods:{
					foo:function () {
						// implementation of foo static method
					},
					bar:function () {
						// implementation of bar static method
					}
				}
			});
			...............................................

		Declaring Static Methods After Subclassing, Using MyClass.instanceMethods
			Static methods can be declared for a class after the class has already been created, by calling the =MyClass.staticMethods= method on the class.

			When calling the =MyClass.staticMethods= method, a static methods declaration object should be provided, containing static method name to implementation function mappings.

			EXAMPLE
			............................................
			MyClass.staticMethods ({
				foo:function () {
					// implementation of foo static method
				},
				bar:function () {
					// implementation of bar static method
				}
			});
			............................................

	Static Properties
		Static properties are non-function type values that are assigned on the class.

		When a subclass is created, all static properties of the superclass are inherited by the subclass through a clone-copy operation (the exception to this is `non-inheritable statics` that are registered with `the MyClass.nonInheritableStatics static property`). Once a subclass is created, changing the inherited static properties on the superclass has no effect on the subclass.

		Static properties can be declared for a class in any of the following ways...

		Declaring Static Properties During Subclassing
			Static properties can be declared for a class when the class is created, by using the optional =featuresByTypeOBJ= parameter when calling the =Uize.Class.subclass= static method.

			The `features declaration object` should contain a =staticProperties= property whose value should be an object containing mappings of static property names to initial values.

			EXAMPLE
			....................................
			var MyClass = Uize.Class.subclass ({
				staticProperties:{
					foo:'bar',
					baz:'qux'
				}
			});
			....................................

		Declaring Static Properties After Subclassing, Using MyClass.declare
			Static properties can be declared for a class after the class has already been created, by calling the =MyClass.declare= method on the class.

			The `features declaration object` passed to the =MyClass.declare= method should contain a =staticProperties= property whose value should be an object containing mappings of static property names to initial values.

			EXAMPLE
			.....................
			MyClass.declare ({
				staticProperties:{
					foo:'bar',
					baz:'qux'
				}
			});
			.....................

		Declaring Static Properties After Subclassing, Using MyClass.staticProperties
			Static properties can be declared for a class after the class has already been created, by calling the =MyClass.staticProperties= method on the class.

			When calling the =MyClass.staticProperties= method, a static properties declaration object should be provided, containing mappings of static property names to initial values.

			EXAMPLE
			...........................
			MyClass.staticProperties ({
				foo:'bar',
				baz:'qux'
			});
			...........................

	State Properties
		State properties are instance properties with special features that, among other things, ties them into the event system so that changes in their values can be easily observed.

		When a subclass is created, all state properties of the superclass are inherited by the subclass through a clone-copy operation. Once a subclass is created, changing the inherited state properties on the superclass has no effect on the subclass. For a detailed discussion of state properties and the various features supported for them, consult the [[state-properties.html][State Properties explainer]].

		State properties can be declared for a class in any of the following ways...

		Declaring State Properties During Subclassing
			State properties can be declared for a class when the class is created, by using the optional =featuresByTypeOBJ= parameter when calling the =Uize.Class.subclass= static method.

			The `features declaration object` should contain a =stateProperties= property whose value should be an object containing mappings of state property names to property profiles.

			EXAMPLE
			.........................................................................
			var MyClass = Uize.Class.subclass ({
				stateProperties:{
					width:{
						conformer:function (value) {return Uize.constrain (value,1,50)},
						value:10
					},
					height:{
						conformer:function (value) {return Uize.constrain (value,1,50)},
						value:10
					}
				}
			});
			.........................................................................

		Declaring State Properties After Subclassing, Using MyClass.declare
			State properties can be declared for a class after the class has already been created, by calling the =MyClass.declare= method on the class.

			The `features declaration object` passed to the =MyClass.declare= method should contain a =stateProperties= property whose value should be an object containing mappings of state property names to property profiles.

			EXAMPLE
			.........................................................................
			MyClass.declare ({
				stateProperties:{
					width:{
						conformer:function (value) {return Uize.constrain (value,1,50)},
						value:10
					},
					height:{
						conformer:function (value) {return Uize.constrain (value,1,50)},
						value:10
					}
				}
			});
			.........................................................................

		Declaring State Properties After Subclassing, Using MyClass.instanceProperties
			State properties can be declared for a class after the class has already been created, by calling the =MyClass.stateProperties= method on the class.

			When calling the =MyClass.stateProperties= method, a state properties declaration object should be provided, containing mappings of state property names to property profiles.

			EXAMPLE
			......................................................................
			MyClass.stateProperties ({
				width:{
					conformer:function (value) {return Uize.constrain (value,1,50)},
					value:10
				},
				height:{
					conformer:function (value) {return Uize.constrain (value,1,50)},
					value:10
				}
			});
			......................................................................

	Dual Context Methods
		.

	Dual Context Properties
		.

Constructor Mechanism
	When an instance of a UIZE class is created, construction involves three phases: the =alphastructor= phase, the state property initialization phase, and the =omegastructor= phase.

	### Constructors are Cumulative
		.

	### Two Phase Construction
		.

	Alphastructor
		The alphastructor is a function that is executed before the state properties for an instance are initialized, and before the =omegastructor= function is executed.

		An alphastructor is declared by specifying a value for the =alphastructor= property of the feature declaration object when calling the superclass' =subclass= method.

		EXAMPLE
		....................................
		var MyClass = Uize.Class.subclass ({
			alphastructor:function () {
				this._someArray = [];
			}
		});
		....................................

		Code inside the alphastructor can set up private "scaffolding" type properties that need to be already in existence by the time any of the state properties are initialized. This allows =onChange= handlers for the state properties to count on certain foundation having been built.

		Because of when it is executed, code inside the alphastructor function cannot rely on the instance's state properties being initialized to the values passed to the constructor.

		EXAMPLE
		......................................
		var
			MyClass = Uize.Class.subclass ({
				alphastructor:function () {
					alert (this.get ('foo'));
				}
			}),
			myClass = new MyClass ({foo:'bar'})
		;
		......................................

		In this example, when the new instance of =MyClass= is created with the value ='bar'= specified for its =foo= state property, the alert inside the alphastructor will display the value =undefined=. This is by design and is an important nuance to take note of.

		Alphastructor Chain
			.

	Omegastructor
		The =omegastructor= is a function that is executed after the =alphastructor= function is executed, and after the state properties for an instance are initialized.

		Omegastructor Chain
			.

Inheritance
	The =Uize.Class= base class provides a mechanism for inheriting `features` declared for the class being subclassed, including the `alphastructor`, `omegastructor`, `static methods`, `static properties`, `instance methods`, `instance properties`, `state properties`, etc.

	The inheritance system that is implemented in the =Uize.Class= base class overcomes some of the weaknesses of a superficial prototype-based approach to inheritance.

	### What Gets Inherited
		.

	### Constructors are Cumulative
		.

	Overriding Inherited Features
		Features that are inherited from a superclass can be overridden in exactly the same way as they are declared.

		Overriding Instance Methods and Properties
			Overriding instance methods and properties of a superclass is easy. It's just a matter of re-assigning.

			EXAMPLE
			...................................................................................................
			var MyClass = Uize.Class.subclass ({      // create a class with an instance method
				instanceMethods:{
					foo:function () {alert ('bar')}
				}
			});

			var MySubclass = MyClass.subclass ({      // create subclass and override inherited instance method
				instanceMethods:{
					foo:function () {
						alert ('foo');
						MyClass.doMy (this,'foo');  // call superclass' version of foo instance method
					}
				}
			});

			var myClassInstance = new MyClass;        // create an instance of the class
			myClassInstance.foo ();                   // call foo method on instance of class

			var mySubclassInstance = new MySubclass;  // create an instance of the subclass
			mySubclassInstance.foo ();                // call foo method on instance of subclass
			...................................................................................................

			In this example, the =foo= instance method of the subclass has been overrided so that it first alerts the text "foo" and then calls the =foo= method implementation from the superclass and alerts the text "bar".

			Typically, the code that implements the methods of a subclass is near (or in the same scope as) the code that creates the subclass, so the subclass knows its superclass. When you start digging into subclass modules, you will encounter this reference to the superclass in the form of the =_superclass= variable (named such by convention).

		Overriding Static Methods and Properties
			Overriding static methods and properties of a superclass is easy. It's just a matter of re-assigning.

			EXAMPLE
			............................................................................................
			var MyClass = Uize.Class.subclass ({  // create a class with a static method
				staticMethods:{
					myStaticMethod:function () {alert ('foo')}
				}
			});

			var MySubclass = MyClass.subclass ({  // create subclass, overriding inherited static method
				staticMethods:{
					myStaticMethod:function () {alert ('bar')}
				}
			});

			myClass.myStaticMethod ();            // call myStaticMethod on MyClass
			mySubclass.myStaticMethod ();         // call myStaticMethod on MySubclass
			............................................................................................

			In this example, =MySubclass= is a subclass of =MyClass=, and both classes have a static method =myStaticMethod=. By subclassing =MyClass=, =MySubclass= inherits the implementation of =myStaticMethod= from =MyClass=. Re-assigning the =myStaticMethod= property of =MySubclass= overrides the inherited implementation without affecting =MyClass=. So, calling =myStaticMethod= on =MyClass= will product the text "foo" in an alert dialog, while calling =myStaticMethod= on =MySubclass= will product the text "bar" in an alert dialog.

			Calling a Subclass Version of a Static Method
				One may implement a class in such a way that a static method is intended to be overrided by a subclass. And in such cases, one may also wish the superclass' implementation to be guaranteed to always use the subclass' version of the static method.

				Calling a subclass' version of a static method can be done in two ways, depending on whether the code is in the implementation for an instance method or for a static method of the superclass.

				The Instance Method Case
					Within an instance method's implementation, one can use the =Class= instance property to reference the actual class of the instance - even in the superclass' code - as in...

					.......................................................................................
					var MyClass = Uize.Class.subclass ({
						instanceMethods:{
							myInstanceMethod:function () {
								this.Class.myStaticMethod (); // call myStaticMethod static method on subclass
							}
						}
					});
					.......................................................................................

					Now, in the case of an instance of =MyClass=, the =myStaticMethod= static method will be called on =MyClass=. However, in the case of an instance of =MySubclass= (that is a subclass of =MyClass=), the =myStaticMethod= static method will be called on =MySubclass=, even though the =myInstanceMethod= instance method is implemented by =MyClass=. If =MySubclass= didn't override the implementation inherited from =MyClass=, then there will be no difference in the outcome.

					Let's take a look at an example...

					EXAMPLE
					.........................................................................................
					var MyClass = Uize.Class.subclass ({      // create a class
						staticMethods:{
							myStaticMethod:function () {
								alert ('MyClass');
							}
						},
						instanceMethods:{
							myInstanceMethod:function () {
								this.Class.myStaticMethod ();
							}
						}
					});

					var MySubclass = MyClass.subclass ({      // subclass the class, overriding static method
						staticMethods:{
							myStaticMethod:function () {
								alert ('MySubclass');
							}
						}
					});

					var mySubclassInstance = new MySubclass;  // create instance of MySubclass
					mySubclassInstance.myInstanceMethod ();   // call myInstanceMethod
					.........................................................................................

					In this example, =MyClass= implements the static method =MyClass.myStaticMethod=. Now, =MySubclass= overrides the implementation of =myStaticMethod= inherited from =MyClass=. The implementation of =myInstanceMethod= (inherited from =MyClass=) uses the =Class= property to get a reference to the actual class of an instance on which the method is being called. So, when this method is called on the instance of =MySubclass= named =mySubclassInstance=, the overrided form of =myStaticMethod= (implemented by =MySubclass=) is called, resulting in the text "MySubclass" being displayed in the alert dialog - *not* the text "MyClass".

				The Static Method Case
					Within a static method's implementation, one can use the =this= keyword to reference the actual class - even in the superclass' code - as in...

					......................................
					MyClass.myStaticMethod = function () {
						this.myOtherStaticMethod ();
					};
					......................................

					Let's take a look at an example...

					EXAMPLE
					...............................................................................................
					MyClass = Uize.Class.subclass ({         // create a class with two static methods
						staticMethods:{
							myStaticMethod:function () {
								this.myOtherStaticMethod ();
							},
							myOtherStaticMethod:function () {
								alert ('MyClass');
							}
						}
					});

					MySubclass = MyClass.subclass ({         // create subclass, overriding inherited static method
						staticMethods:{
							myOtherStaticMethod:function () {
								alert ('MySubclass');
							}
						}
					});

					MySubclass.myStaticMethod ();            // call inherited static method
					...............................................................................................

					In this example, =MyClass= implements the two static methods =MyClass.myStaticMethod= and =MyClass.myOtherStaticMethod=. The implementation of =MyClass.myStaticMethod= wants to always call the subclass' version of =myOtherStaticMethod=. So, instead of calling it as =MyClass.myOtherStaticMethod ()=, it calls it as =this.myOtherStaticMethod ()=.

					Now, if =myStaticMethod= is called on =MyClass=, then =this= will be a reference to =MyClass=. However, if =myStaticMethod= is called on =MySubclass=, then =this= will be a reference to =MySubclass=. Consequently, using =this= guarantees that the subclass' version will be called. In this example, =MySubclass= overrides the implementation of =myOtherStaticMethod= inherited from =MyClass=, so the statement =MySubclass.myStaticMethod ()= will result in the text "MySubclass" being displayed in the alert dialog - *not* the text "MyClass".

		Overriding State Property Values
			The initial value for a state property inherited from a superclass can be overrided by calling the =MyClass.set= static method that is inherited from the =Uize.Class= base class.

			The initial value for a state property is declared by specifying the =value= property in the profile for the state property, as follows...

			EXAMPLE
			..................................................................................
			var MyClass = Uize.Class.subclass ({   // create a class with a foo state property
				stateProperties:{
					_foo:{
						name:'foo',
						onChange:function () {
							// code to handle a change in foo's value
						},
						value:'bar'
					}
				}
			});

			var _myClassInstance = new MyClass;    // create instance of MyClass
			alert (_myClassInstance.get ('foo'));  // alert value of foo state property
			..................................................................................

			In the above example, the text "bar" will be displayed in the alert dialog.

			Now, the initial value for the =foo= state property inherited from =MyClass= can be overrided in a subclass, as follows...

			EXAMPLE
			..............................................................................................
			var MyClass = Uize.Class.subclass ({   // create a class with a foo state property
				stateProperties:{
					_foo:{
						name:'foo',
						onChange:function () {
							// code to handle a change in foo's value
						},
						value:'bar'
					}
				}
			});

			var MySubclass = MyClass.subclass ({   // subclass the class, overriding initial value for foo
				set:{foo:'NOT BAR'}
			});

			var _mySubclassInstance = new MySubclass;  // create instance of MySubclass
			alert (_mySubclassInstance.get ('foo'));   // alert value of foo state property
			..............................................................................................

			In this example, we have now created a subclass of =MyClass= named =MySubclass=. The new subclass inherits the =foo= state property, along with its initial value of ='bar'= that is declared in =MyClass=. When creating the =MySubclass= subclass, we use the =set= declaration to change the initial value of this state property to ='NOT BAR'=. This is equivalent to calling =MySubclass.set=, but we can tuck it neatly into the subclassing statement. Now, the fresh instance of =MySubclass= that is created, named =_mySubclassInstance=, will have the initial value ='NOT BAR'= for its =foo= state property, and the alert dialog will display this text.

	### Inheriting State Properties
		State properties declared for a class are inherited when creating a subclass.

		EXAMPLE
		..........................................................................
		var MyClass = Uize.Class.subclass ();  // create a class
		MyClass.stateProperties ({             // declare the "foo" state property
			_foo:{
				name:'foo',
				onChange:function () {
					// code to handle a change in foo's value
				},
				value:'initial value for foo'
			}
		});

		var MySubclass = MyClass.subclass ();  // create a subclass
		MySubclass.stateProperties ({          // declare the "bar" state property
			_bar:{
				name:'bar',
				onChange:function () {
					// code to handle a change in bar's value
				},
				value:'initial value for bar'
			}
		});
		..........................................................................

		After the above code has executed, the class =MySubclass= will have the two state properties =foo= and =bar=.

	Features that All Classes Inherit
		As part of the foundation for developing classes in UIZE, the =Uize.Class= base class provides its subclasses with numerous inherited systems, such as the `event system`, `state properties system`, `instance creation system`, `subclassing system`, and `conditions and derivations`.

		###
			Event System
				.

			State Properties System
				.

				- briefly mention Changed events

			Instance Creation System
				The "no new" Mechanism
				state properties initialization

			Subclassing System
				- create a subclass
				- declare feature and/or override inherited features

			Conditions and Derivations
				.

				ties events and state properties together

Advanced Topics
	Private vs. Public
		By convention, private methods and properties - both instance and static - are distinguished from public methods and properties by prefixing their names with an underscore.

		EXAMPLE
		........................................................................
		var MyClass = Uize.Class.subclass ({
			instanceMethods:{
				_myPrivateInstanceMethod:function () {  // private instance method
					// do stuff
				},
				myPublicInstanceMethod:function () {    // public instance method
					// do stuff
				}
			},

			staticMethods:{
				_myPrivateStaticMethod:function () {    // private static method
					// do stuff
				},
				myPublicStaticMethod:function () {      // public static method
					// do stuff
				}
			}
		});
		........................................................................

		Technically, such private methods and properties are not thoroughly private and can be accessed as public methods or properties. However, because their names will be changed by the Scruncher when the code is scrunched to minimize its size, one cannot reliably access these methods and properties. This is a kind of "soft privacy".

		IMPORTANT

		When creating subclasses, it is important not to access methods or properties defined in the superclass with private names. The code will work when it is unscrunched, but there is no guarantee *what* your subclass will be accessing when all the code is scrunched.

		Private and Public References
			Sometimes, for size optimization, it can be helpful to assign a private reference to a public instance method.

			EXAMPLE
			....................................................................................
			_classPrototype.myInstanceMethod = _classPrototype._myInstanceMethod = function () {
				// do stuff
			};
			....................................................................................

			In this example, the private instance method =_myInstanceMethod= is mapped to the public instance method =myInstanceMethod=. Inside the class' implementation, the private name can be used. This is useful if there will be many calls - in the class' implementation - to an instance method that's publicly accessible, as the private name will be reduced in size by the Scruncher.

			IMPORTANT
			- Be careful when using this technique, because using a private reference to a public instance method doesn't ensure that a class' implementation will be calling a subclass' override of the instance method, since the subclass won't assign a value for the private identifier.
			- This technique is not useful for public instance properties that are expected to be assigned through the public interface, since assigning a value using the public name will not assign that same value to the private version.
			- This technique *could* be used for public instance properties that are intended to be read only and are not intended to be set outside of the class' implementation code. The technique *could* also be used if the value of the property was an object and was never intended to be changed, even if the contents of the object is expected to be modified by code outside of the class' implementation.

	Non-inheritable Statics
		Unless otherwise specified, all static features - methods as well as properties - of a =Uize.Class= subclass are inherited in turn by their subclasses.

		There are times, however, when there is no compelling reason for a static feature of a class to be inherited by its subclasses. In fact, in some cases too many inherited static features can just clutter subclasses in the class hierarchy with cruft that they neither need nor care about. In such cases, the inheritance system of the UIZE JavaScript Framework provides a way to "register" static features of a class as being non-inheritable. This is done using the =MyClass.nonInheritableStatics= static property.

		The MyClass.nonInheritableStatics Static Property
			The =MyClass.nonInheritableStatics= static property is a lookup object, automatically created for a class, in which you can register the static features (methods or properties) of the class that should *not* be inherited when that class is subclassed.

			Each property of the =MyClass.nonInheritableStatics= lookup object represents a single static feature of the class that should not be inherited by subclasses, where the name of each property should be the name of a static feature (excluding the module name), and the value of each property should be a truthy value (such as =true=, =1=, ='foo'=, =[]=, ={}=, etc.). After a class has been created, non-inheritable statics can be registered for that class by assigning properties to the class' =MyClass.nonInheritableStatics= static property, as shown in the example below...

			EXAMPLE
			...........................................................................
			MyClass = Uize.Class.subclass ({
				staticMethods:{
					someUtilityFunction:function () {
						// do something of great utility
					}
				}
			});
			MyClass.nonInheritableStatics.someUtilityFunction = 1;

			MyClassSubclass = MyClass.subclass ();
			alert (MyClassSubclass.someUtilityFunction); // alerts the text "undefined"
			...........................................................................

			In the above example, the =MyClass.someUtilityFunction= static method of the class =MyClass= has been registered as a non-inheritable static. This is done by the statement =MyClass.nonInheritableStatics.someUtilityFunction &#61; 1=. Now, when the =MyClassSubclass= class is created by calling the =MyClass.subclass= method, the new subclass that is created does not get the =someUtilityFunction= static feature. Therefore, the =alert= statement displays the text "undefined" in the alert dialog.

			nonInheritableStatics is a Non-inheritable Static
				When a class is created, the =MyClass.nonInheritableStatics= static property is automatically initialized on that class to a fresh object with the value ={nonInheritableStatics:1}=.

				This initial mapping means that the =MyClass.nonInheritableStatics= static property is, itself, not inheritable by subclasses - subclasses get their own fresh object. So, in our example, when the =MyClassSubclass= subclass is created, its fresh =MyClassSubclass.nonInheritableStatics= property does *not* have an entry for the =someUtilityFunction= static feature, because it does not have that static feature and the contents of the =MyClass.someUtilityFunction= object is not inherited by the =MyClassSubclass= class.

		All Types of Statics Can Be Non-inheritable
			All types of static features of a class can be registered as non-inheritable - methods as well as properties.

			Registering static properties as non-inheritable is accomplished in the same way as for static methods. Consider the following example...

			EXAMPLE
			..........................................................................
			MyClass = Uize.Class.subclass ({
				staticProperties:{
					someStaticProperty:'foo'
				}
			});
			MyClass.nonInheritableStatics.someStaticProperty = 1;

			MyClassSubclass = MyClass.subclass ();
			alert (MyClassSubclass.someStaticProperty); // alerts the text "undefined"
			..........................................................................

			In the above example, the alert dialog would display the text "undefined", because the =MyClass.someStaticProperty= static property of the class =MyClass= has been registered as non-inheritable, so it is not inherited by the =MyClassSubclass= class that is created by subclassing =MyClass=.

		Utility Functions Need Not Be Inheritable
			A good case for making a static method non-inheritable is if it is really just a utility function that happens to be stashed in a class' namespace.

			Static methods that are really just utility or helper functions don't care about the context on which they are called. They just happen to be called on a class as a context because they are assigned as properties on a class. Take, for example, the =Uize.Fade.blendValues= static method of the =Uize.Fade= class. You may be calling it on the =Uize.Fade= context, but this utility function's implementation doesn't even reference the =this= keyword - it just doesn't care about the context on which it is called. You could, in fact, assign this static method to a local variable and then call it using that local variable, and it would behave in just the same way as if it were being called on the class. Consider the following example...

			EXAMPLE
			.........................................................
			var blendValues = Uize.Fade.blendValues;
			alert (blendValues (50,100,.5));  // alerts the text "75"
			.........................................................

			In the above example, our local variable =blendValues= is a function reference. When that local variable is used to call the function in order to blend the values =50= and =100=, everything works just fine. The =alert= statement alerts the result of blending =50= and =100= in equal amounts, which is the =75=. Because the =Uize.Fade.blendValues= static method doesn't operate on a =Uize.Fade= subclass or need a =Uize.Fade= subclass as its context when it is called, there's no compelling reason for it to be inheritable, and so it is not.

		When Statics Should Be Inheritable
			Whenever a static method or property is intended to be unique to its class context, and it is also desirable for that method or property to be inherited by subclasses, then it should *not* be registered as non-inheritable.

			Examples of some static methods in the =Uize.Class= base class that are inheritable are the =Uize.Class.set=, =Uize.Class.get=, =Uize.Class.toggle=, =Uize.Class.fire=, =Uize.Class.wire=, =Uize.Class.subclass=, and =Uize.Class.stateProperties= methods. All of these methods act on the class context. So, for example, calling =Uize.Class.subclass= is different to calling =Uize.Widget.subclass=. The =Uize.Class.subclass= method, which is inherited by all =Uize.Class= subclasses, uses the context of the class on which it is called. Calling the =Uize.Class.subclass= method returns a subclass of =Uize.Class=, while calling the =Uize.Widget.subclass= method returns a subclass of =Uize.Widget= - even though both of these methods reference the same function for their implementation (in other words, the statement =alert (Uize.Class.subclass &#61;&#61; Uize.Widget.subclass)= would alert the text "true").

		Inheritability of Static Features is Noted in Module References
			All static features of modules of the UIZE JavaScript Framework are noted as being either inheritable or non-inheritable in the reference documentation for those features.

			The inheritability of the static features of a module is noted in the IMPLEMENTATION INFO notes of the reference documentation for the features in the module's reference. So, for example, if you went to the reference documentation for the =Uize.Class.set= static method of the =Uize.Class= base class, you would see it noted that the feature is inherited by subclasses. In contrast, if you went to the reference documentation for the =Uize.Fade.blendValues= static method of the =Uize.Fade= class, you would see it noted that the feature is *not* inherited by subclasses.

	Singletons
		The UIZE JavaScript Framework provides support for [[http://en.wikipedia.org/wiki/Singleton_pattern][singletons]] in the form of the =Uize.Class.singleton= static method that is implemented in the =Uize.Class= base class and is inherited by all =Uize.Class= subclasses.

		Every Class Supports Singletons
			Because singleton support is implemented in the =Uize.Class= base class, a singleton for any =Uize.Class= subclass can be created by calling the =singleton= static method on the class.

			EXAMPLE
			.......................................................
			var fileSystem = Uize.Services.FileSystem.singleton ();
			.......................................................

			In the above example, the =Uize.Services.FileSystem= class is a subclass of the =Uize.Service= class, which is itself a subclass of the =Uize.Class= base class. Therefore, a singleton can be created using the =Uize.Services.FileSystem.singleton= static method that is inherited from =Uize.Class=.

		A Single Singleton
			As expected with singletons, multiple separate calls to the =singleton= static method will return a reference to the same singleton.

			EXAMPLE
			........................................................................
			var
				fileSystemSingleton1 = Uize.Services.FileSystem.singleton (),
				fileSystemSingleton2 = Uize.Services.FileSystem.singleton ()
			;
			alert (fileSystemSingleton1 === fileSystemSingleton2);  // alerts "true"
			........................................................................

			In the above example, both the =fileSystemSingleton1= and =fileSystemSingleton2= variables are set to be a singleton of the =Uize.Services.FileSystem= class. Therefore, when their values are compared using a strict equality, they are found to be equal.

		Compelling Use Cases for Singletons
			A typical and compelling use case for the singleton feature is with service classes, where one typically wants to share a single instance of a service class amongst multiple disparate users of the service.

			In the case of service classes, one may instantiate and set up the singleton of a service in the environment (which will likely be a Web page for services that are to run in Web applications). Then, in other code that is to run in the environment and use the service, the singleton of the service can simply be obtained and used - the service doesn't need to be initialized by all the users because the same shared singleton of the service class is initialized and set up in the environment.

		Singleton Scope
			As a convenience, the =singleton= static method provides a way to optionally create singletons in a custom scope.

			A scope for a singleton of a class is specified using the optional =scopeSTR= parameter, as follows...

			EXAMPLE
			....................................................................................
			var fileSystemForBuildScripts = Uize.Services.FileSystem.singleton ('buildScripts');
			....................................................................................

			In the above example, a singleton of the =Uize.Services.FileSystem= class is being created in a scope we have decided to call "buildScripts". Now, any other build script code that wants to get a reference to this singleton can perform the same operation, specifying ='buildScripts'= as the value for the =scopeSTR= parameter. With this kind of arrangement, other code can now use the same =Uize.Services.FileSystem= service class in a different scope. In different scopes, the different singletons may be set up with different service adapters and initialized differently to perform different I/O.

			A Single Singleton Per Scope
				The exception to the rule of `a single singleton` is when using the `singleton scope` feature.

				EXAMPLE
				......................................................................
				var
					fileSystemInScopeA = Uize.Services.FileSystem.singleton ('scopeA'),
					fileSystemInScopeB = Uize.Services.FileSystem.singleton ('scopeB')
				;
				alert (fileSystemInScopeA === fileSystemInScopeB);  // alerts "false"
				......................................................................

				In the above example, two singletons of the =Uize.Services.FileSystem= class are being created: one in a scope we've called "scopeA" and the other in a scope we've called "scopeB". When the values of the =fileSystemInScopeA= and =fileSystemInScopeB= variables are compared using a strict equality, they are found to *not* be equal. However, if we called the =singleton= method multiple times for "scopeA", we would always get back the same singleton for this scope, and similarly with "scopeB".

			Designing Classes to Support Singleton Scope
				In order to be able to take advantage of the `singleton scope` feature, your classes need to be designed correctly.

				In order to correctly support singletons in different scopes, your class should not store state for a singleton as statics on the class, but should instead use instance properties. Provided your classes are designed correctly, you can have multiple singletons instantiated for different scopes that you define, so that different sets of distributed code can share their own singleton instances, and for each differently scoped singleton the singleton may be initialized or set up in a different way.

			Singleton Scope is Effectively Global
				A `singleton scope` is effectively global for a given class.

				Therefore, if you have distributed code that is making use of the singleton feature and you are specifying a custom scope, you need to have a good degree of confidence that you won't have totally different code trying to use the same scope name for a singleton of a class where the initialization and usage of the singleton is different. This is the age old problem with things that are global in nature. The globalness of singletons is both the upside and the downside, so you should `use the singleton feature sparingly`.

		Initial State for Singletons
			A singleton can be created with an initial state by specifying the optional =propertiesOBJ= second parameter.

			EXAMPLE
			.................................................................................................
			var fileSystemForBuildScripts = Uize.Services.FileSystem.singleton ('',{defaultEncoding:'utf8'});
			.................................................................................................

			In the above example, a singleton is being created for the =Uize.Services.FileSystem= class. Because the first parameter of the =singleton= method is the singleton scope, if we want to use the default scope we need to specify an empty string. The second parameter is the state for the singleton, where the value is an object that will be passed to the constructor of the class if the singleton has not yet been created for the scope, or used in a call to the =set= method if the singleton already exists in the scope.

		Use the Singleton Feature Sparingly
			While there are a few `compelling use cases for singletons`, one should nevertheless use the singleton feature sparingly and with caution.

			The very advantage of singletons, which is that they can be shared by disparate pieces of code, can also become a disadvantage. Singletons can be regarded as being, in effect, globals in the scope of the class on which they are created, or the `singleton scope` in which they are created. This consequence brings with it the kinds of drawbacks that globals have more generally. Singletons aren't as egregious as global variables, and the `singleton scope` facility goes some way to alleviating the global nature of singletons. Nevertheless, before resorting to using singletons, consider first if there are other alternatives. In UIZE, you will find singletons mostly advocated for use with service classes.

	### OTHER NOTES
		Private Static Methods
			- you really could just use global functions
			- is it a method or a function?
			- you can use =this= to reference other statics that might be overrided in a subclass

		Private Static Properties
			- when can you just use global variables?
			- in some cases, you might want private static properties that are inherited

		Private Instance Methods
			- two approaches
				- function whose first argument is context / this
				- function that is called as instance method on context, using _myPrivateMethod.call (_this)

		Public Static Properties
			- accessing subclass' value from superclass

		Adding Handlers for Instance Events on Self
			instance event is fired in superclass' implementation

		Adding Handlers for State Property Changed Events on Self
			state property is declared by superclass

		Accessing State Properties From Subclass

		- don't expose purely static methods as instance methods just for convenience
			example
				MyClass.prototype.someStaticMethod = MyClass.someStaticMethod;

				now you can do...

				var instanceOfMyClass = new MyClass;
				instanceOfMyClass.someStaticMethod ();

				...instead, should use...

				var instanceOfMyClass = new MyClass;
				instanceOfMyClass.Class.someStaticMethod ();

