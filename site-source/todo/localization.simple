This document outlines requirements for a localization system that can serve the needs of user interface for multiple products using various different UI technologies.

General Requirements for a Localization System
	A localization system should satisfy the following requirements for all technologies.

	Localization Features
		A localization system should support the following basic features...

		String Selection by Key
			The localization system should be able to select an appropriate string by key, from a set of locale strings, that is translated for one of the supported locales.

			To support the possibility of all strings for all UI components for all locales being present within the same database (possibly as a side effect of a certain translation work flow processes, the key used to identify a string may contain the following parts...

			- locale
			- product / component path
			- version
			- string key
			- variant identifier

		String Substitution
			The localization should support substitution of values into an arbitrary number of tokens inside locale strings.

			Furthermore, the substitution system should support values being of specific types which can inform formatting of their values and provide cues to a `string variant sub-selection` mechanism that can select available variants that best match the qualities of the substitution values.

		String Variant Sub-selection
			In cases where genders and/or quantities need to affect the translation of a locale string for a specific language, the localization systems needs to support the sub-selection of the best string variant.

			Since string variants may not be necessary (and may not exist) for all languages, the string variant sub-selection mechanism should support a system for fallbacks, such that a more generic variant is selected unless a more specific variant is defined. To allow the desired priority to be controlled, a simple algorithm can be employed that iterates through all the defined variants and selects the last matching variant, leaving it up to the author of the translations to order the variants from most general to most specific.

			An Example
				To illustrate this with an example, say that a string has two substitutions, one for a person's name and the other for an object, where the person's name will have an associated gender and the object will have an associated quantity, both of which will be provided as translation cues to the string variant sub-selection mechanism.

				Now, in the worst case, the translation service may translate the locale string for the most rudimentary substitution, providing only a single base variant. In the best case scenario, the translation service may translate the locale string for all possible logical values of gender and quantity. In between these two extreme cases, a translation service may translate the locale string separately for possible values for gender and for possible values of quantity, but not combinations of the possible values. In such a case, the order of the translated strings can determine whether a matching translation for a possible value of gender takes priority over a matching value for a possible value of quantity, or vice versa.

		Number Formatting
			The localization system should support formatting a number correctly for the locale.

			Most locales, for example, will require a "." (period character) to be used to indicate the decimal point, while some specific locales will require that a "," (comma character) be used.

		Currency Formatting
			The localization system should support formatting of currency values appropriately for a locale.

			Formatting a currency value correctly involves a combination of using the appropriate currency unit symbol and placement, along with the appropriate number formatting for the locale. It is not the responsibility of the localization system to perform currency conversion based upon prevailing exchange rates - that can remain the responsibility of the application.

			In the case of substituting currency values into locale strings, it should not be the responsibility of the code providing the currency value substitution to perform pre-processing of the currency value in order to format it, but ideally the currency value provided to the substitution mechanism would be of a type that would cue the locale string processing code to invoke the appropriate formatting before value substitution. Either the value type can be provided to the locale string processing code, or the value type for a particular token could be explicitly provided in a descriptor for the token, as in...

			...........................................................................
			amountPaid: The amount of {paid:currency} has been debited to your account.
			...........................................................................

		Date Formatting
			The localization system should support formatting a date correctly for the locale, including the appropriate translations of day and month names.

			As with `currency formatting`, when date type values are substituted into locale strings, it should not be required that the code providing the date value perform any pre-processing, but the substitution mechanism should be able to perform formatting of the date value as needed as part of producing the translated string.

			.............................................................
			joinDate: You activated your service on {activationDate:date}
			.............................................................

			Optionally, formatting cues may be provided - either as ancillary data that is provided along with and as part of the date value, or as an additional descriptor for the token in the locale string.

			...................................................................
			joinDate: You activated your service on {activationDate:date,short}
			...................................................................

		Measurement Units
			The localization system should provide support for localizing measurement values for a locale, which may involve converting the measurement values from values expressed in a canonical system of units, such as the SI / metric system, to measurement values expressed in a system like the Imperial System.

			Imperial vs Metric
				The localization system should provide a defaulting behavior for selection between showing measurements in Imperial vs Metric systems for any given type of measurement, with the ability of the user to override the default for all types or on a type-by-type basis.

				Unless overridden by the user or the application, the Imperial system would be used for select types of measurements (such as length, area, volume, weight, temperature, speed, etc. measurements) for select locales (primarily the US, UK, Canada, Australia, New Zealand, and some others), and the Metric System would be used for all other locales. The Metric system would be used for all other types of measurements for which the Metric System is the universally adopted system of measurement (such as voltage, power consumption, etc. measurements) - even in locales that have a historical preference for the Imperial System.

			Unit Symbol Localization
				Beyond the system of units that is used for a particular type of measurement, the symbols that are used to denote the unit also needs to be localized.

				In many locales where the Metric System is used for measurements, the standardized and non-localized metric unit names may be acceptable, but in some locales this is not desirable, so the system needs to support the ability to provide translations for unit names for any unit type for any locale, with a suitable defaulting / fallback mechanism to reduce redundancy where unit names do not need special translation.

		String Collation (aka Sorting)
			The localization system should support string collation (sorting), taking into account how ordering rules apply to the character set in use by the language.

			Sort orders such as alphabetical or ASCIIbetical are not meaningful for the writing systems for certain languages, such as Japanese kanji, and a different type of collation algorithm needs to be applied. The localization system can provide collation as part of a service API, considering that collation for certain languages can be complex and have a performance cost that is not desirable for a client device.

			The localization system should provide the client with cues to indicate whether sorting can be performed on the client side with a simple algorithm or whether sorting should be offloaded to a service, and the client code should be written to anticipate that sorting might be a process involving an asynchronous service.

		RTL Support
			As far as RTL (right-to-left) layout is concerned, the localization system should support at least the ability to determine whether an RTL layout should be used for a specific locale.

			Once it is known that RTL layout should be used for a locale, it is the responsibility of the UI framework to invoke RTL layout and the responsibility of the various UI components to implement support for RTL in their styling.

		Style Conditionalization
			The UI framework should support selection of styling code based upon the locale information queried from the localization system.

			Style conditionalization can be performed in either (or both) of two waysâ€¦

			- selection of a style variant for the locale that materializes conditionalization into the styling code through a compilation process (so, each locale gets a modified version of common, parameterized style code)
			- loading of a base style for all locales combined with loading of a locale specific set of style overrides

		Media Conditionalization
			The localization system should facilitate the conditional selection of media appropriate for a given locale.

			At the very least, the localization system should provide the necessary locale information to inform conditional selection of media, but the system may also provide a framework for defining locale specific overrides for media along with a system for selecting a best match for media for a given locale, with a fallback heuristic to address situations where very locale specific media variants are not provided.

		Locale Content Tailoring
			The localization system should provide an application the locale information necessary to allow it to tailor its content to be most suitable for any given locale.

			Content Filtering vs Content Ranking
				While it is not the responsibility of the localization system to determine suitability of content for a locale, the basic locale information provided by the system can be used by a separate content system to inform filtering and ranking of content for any locale.

				For instance, certain content may never be appropriate for a specific locale and it may be desirable to filter it out completely. In cases where content is permissible for a specific locale but is not best suited for that locale, the locale can be used to effect a negative weighting for such content for content searches and feeds in that locale. In such a content filtering and ranking system, locale may be just one of many dimensions that impacts filtering and ranking, along with dimensions such as user's age, sex, occupation, ethnicity, etc.

		Feature Configuration
			The localization system should provide an application the locale information necessary for it to determine which features of the application should be enabled and which should be disabled.

			It is not the responsibility of the localization system to resolve feature configuration for a specific locale - this is the responsibility of a separate decision engine that will likely accept multiple input parameters to allow multi-dimensional configuration. That is to say, whether or not a particular feature is enabled may be determined by multiple different factors, one of which may be the user's locale (or data derived from the user's locale). In this sense, feature configuration is similar to `locale content tailoring`.

	Required Characteristics of Localization System
		Switchability on the Client
			It should be possible to switch the locale to be used throughout an application on the client.

		Concurrency on the Server
			It should be possible to server an application to users in multiple different locales from the same server.

			To this end, it would not be a viable solution to build the the set of localized assets for each of the supported locales while keeping the URIs the same - the URI for each localized asset would have to be different per locale, which also means that the client would have to request the appropriate localized version of an asset for the client's locale. Not encoding the locale into the path of the URI for a localized asset would leave only the option of serving the localized assets for different locales from different domains and, while there may in many cases be domains dedicated to certain of the major locales, it cannot be assumed to always be the case, Furthermore, it may be desirable to serve all the static assets from a central CDN with a common domain, even while the application may be served from locale specific domains.

	Desired Characteristics of Localization System
		Live Locale Switching
			To increase the productivity of those doing translation for of locale strings along with those doing visual testing of localized UI, it should ideally be possibly to switch between locales without incurring a costly full reload of the page or app.

			All UI components would ideally be implemented to allow updated locale strings to be dynamically propagated into the UI, and the app environment would support the ability to switch locale and have the necessary locale strings for the new locale be loaded for all the localized UI controls.

			Live locale switching would ideally be supported at a UI component level, with the ability to use a locale switcher for an individual component. When a component is switched to a new locale, all of its child components and their child components (ie. the entire component tree beneath it) should be switched to the new locale as well.

		Dynamic / Live Updating
			In order to enable more responsive tools for translating locale strings and instantly previewing the translations in the UI, the UI framework's localization mechanism should ideally support dynamically updating the UI as locale strings are modified.

			Given such a live updating mechanism, translators can then visually preview their translations and correct layout issues immediately by making choices between different candidate translations to achieve the best layout for the language they are translating for, rather than having problems slip in and only be discovered during localization QA testing or - even worse - once the code has already been pushed to a production environment.

		Media Template Processing
			While it is desirable to compose locale strings into the presentation as part of a runtime rendering process, it is sometimes not possible to render all parts of the presentation dynamically.

			In cases where it is necessary to localize media assets that cannot be rendered dynamically, because of performance issues or a lack of the rendering technology in the client, it is desirable to have a system in place to allow for rendering of templatized media of various types, either as part of a build process or as an ob-demand process that is load optimized through a type of caching facility.

			An alternative to a media template processing system is to rely solely on `media conditionalization` with the job of rendering templatized media being the responsibility of production processes of a creative department. This can work at a small scale, but becomes increasingly burdensome as product complexity and supported locales increase. A manual production process also does not lend itself well to an integrated translation process.

		Locale String Inheritance
			For any UI component system, whether implemented for Web technologies or native operating system frameworks, certain inheritance characteristics should be supported.

			Inheriting Locale Strings From a Superclass
				For a UI component class that extends / subclasses a UI component base class / superclass, the locale strings of the superclass should be inheritable.

				In this way, a UI component subclass can extend its superclass and gain the benefit of all the localization that has already been done for it, without having to duplicate that effort. The same types of reuse patterns that one may with to employ with other aspects of the code one should also be able to apply to localization.

			Overriding Inherited Locale Strings
				For locale strings inherited from a UI component's superclass, it should be possible to override any or all of them.

				As with other inherited features, overriding a locale string in a UI component subclass should have no effect on the component's superclass and instances of both should be able to coexist in the page together without any conflict.

			Declaring Additional Locale Strings
				For any UI component subclass, it should be possible to augment the set of locale strings inherited from its superclass by declaring additional locale strings for the subclass.

Special Requirements for Web Localization
	Concurrency on the Client
		The UI framework should ideally support multiple locales in use on the client concurrently.

		This will support the ability to perform side-by-side comparisons of multiple instances of the same UI component set to different locales, in order to make judgements on translations as they impact layout, and layout and styling as they impact available translation options, thereby helping to reconcile conflicts between translation and layout/styling.

	Encapsulation of Locale-specific Resources
		The localization system should facilitate the encapsulation of locale-specific resources with the code modules that require those resources.

		A UI framework should make use of the localization system's support for encapsulation of locale resources by encapsulating locale resources for UI components with the components themselves, thus allowing locale resources for UI components to be packaged along with the other code (JavaScript, CSS, HTML, etc.) for the components so that components can be delivered to a client across a network with fewer network requests.

		In order to support encapsulation of locale-specific resources, the localization system should provide support for harvesting locale resources that are distributed throughout a codebase, potentially combining the resources together in a flat database for submission to a translation service, and then redistributing the translated resources to their correct original places throughout the codebase.

	Locale Strings as Dependencies
		A set of locale strings needed by a UI component should be expressed as a dependency of the UI component, in order to provide a standard mechanism by which to load them dynamically during development and by which to package them along with other JavaScript code for deployment to a production environment.

		Parameterized Dependency
			Because it is not possible for a UI component's code to know what locale the code will be run in, expressing a dependency on a set of locale strings can only go as far as providing a base guide, where the runtime environment will determine what exact module is required based upon the locale set for the environment at the time of loading the UI component.

Serialization of Types
	Various value types that can be displayed to the user, either alone or as substitutions in locale strings, may have locale specific serializations.

	Locale-specific formatting of a number value, for instance, can be viewed as a form of locale-specific serialization to string of number type values.

	Currency Values
		Monetary amounts may have locale-specific formatting and an associated currency, but currency, number formatting, and locale can also all be independent of one another.

		No Canonical Currency Units
			Canonical values don't exist for currency values in the same way as they do with linear dimension values, for example.

			Conversion between different currencies must involve a central monetary exchange service that is aware of the up-to-date intercurrency exchange rates - it is not possible to implement static code as part of an internationalization utilities library that can perform conversion for the purpose of display.

			Therefore, a currency value type should always carry the currency for the value independent of the locale setting for the application.

		No One-to-one Locale-to-currency Mapping
			There is not a one-to-one mapping between locale and currency.

			Certain locales may have an associated currency (or currencies), but it can't be assumed that there is a specific currency for a specific locale. Panama, for example, supports both the US Dollar and the Panamanian Balboa.

			In cases where the appropriate currency can't be determined from either the locale in which the application is offered or the locale of the user, the application may wish to make the currency selectable by the user, and the application may also wish to display monetary amounts in two or more currencies. A traveler in the United Kingdom, for example, may have a combination of Pund Sterling and Euros in their wallet and it may be convenient to see amounts in both currencies, with the secondary / non-dominant currency shown in a separate column or in parentheses.

		Number Formatting Versus Currency
			Number formatting and currency formatting can be distinct from one another and should not be conflated.

			For example, in an application that displays amounts denominated in Euros in Germany, there would be an expectation for the correct Euro currency symbol to be used as well as the appropriate use of the period character to delimit thousands and the comma character to indicate the decimal position.

			AMOUNTS DISPLAYED IN GERMANY
			..........................
			â‚¬ 1.234,56  (US $1.973,04)
			..........................

			In contrast, if a Euro-denominated amount were to be displayed as a comparison alongside a US dollar amount to users in the US, there would be an expectation for the thousands in the Euro amount to be delimited using commas and the decimal place indicated by a period.

			AMOUNTS DISPLAYED IN US
			..........................
			â‚¬ 1,234.56  (US $1,973.04)
			..........................

Useful Background Information
	ICU
		[[http://en.wikipedia.org/wiki/International_Components_for_Unicode][ICU]] (International Components for Unicode) is a project first developed by Taligent and then later absorbed into IBM after they acquired Taligent.

		ICU provides code to support correct localization and is available in ports for C/C++ and Java. ICU covers character encoding, formatting of various data types, message formatting, time calculation and timezones, etc. ICU is in quite broad use and forms the basis for some of Google's localization support. They rely on ICU Message Format in their ARB (Application Resource Bundle) format, for example.

		- [[http://site.icu-project.org/home][ICU Homepage]]

	XLIFF
		[[http://en.wikipedia.org/wiki/XLIFF][XLIFF]] (XML Localization Interchange File Format) is an XML-based file format for the transfer of localizable data during the localization process.

		XLIFF was standardized by OASIS in 2002. It's not easy to ascertain the level of adoption of and tools support for XLIFF in the industry.

	ARB
		[[https://code.google.com/p/arb/wiki/ApplicationResourceBundleSpecification][ARB]] (Application Resource Bundle) is a file format advanced by Google to package and organize localization resources.

### Requirements of a Localization System
	- it should be possible to load the necessary module for defining the strings for a locale as a direct dependency for a module, before the module itself is built
	- it should be possible to build a package containing all the locale modules necessary for a specific locale
	- it should be possible to set the locale for an entire widget tree, and have all the widgets in the widget tree reflect the new locale (therefore, locale should be a tree inherited property, like enabled and busy)

	Sample File

	....................
	start: Start
	stop: Stop
	greeting: Hello, <%. user.name %>
	removeSelectedItemsConfirmation: Are you sure you would like to remove the <% totalItems %> selected items?
	....................

	....................
	greeting : Hello, <%. user.name %>.
	greeting { user.gender == 'male' } : Hello, mister <%. user.name %>.
	greeting { user.gender == 'female' } : Hello, missis <%. user.name %>.
	....................



	....................
	{person} gave you {count} {gift}
	....................

	person can be male/female
	count can be 0, 1, 2, more
	gift can be male, female, neuter

