This is a TO DO document for the =Uize.Widget.mEventBindings= mix-in module.

Optimize Self State Property Changes
	When wiring a handler for state property changes a developer has the option to use the =onChange= property passed as part of the definition of the state proprety or an event binding. Using the =onChange= proprety is optimized and better performing, but it will be less confusing if we can steer all use cases to event bindings.
	
	So the solution instead of having developers have to make a choice, is to have mEventBindings add self state property change handlers to the =onChange= property itself.  That way the developer interface is straightforward without having to sacrifice performance. In addition, this will now give subclass widgets the opportunity to easily leverage the same =onChange= optimization, which hadn't been possible before.
	
	Sample Implementation
		Assigning a new handler to the =onChange= will actually append the new handler so after detecting a self state property change, =Uize.Widget.mEventBindings= can do something like the following...
		
		...
		class.stateProperties(
			Uize.pairUp(
				propertyName,
				{onChange:changeHandler}
			)
		);
		...
		
DOM Events Are Not Fired By Default
	When a widget becomes busy or disabled, those states are propogated to its children because those state properties are stateInherited properties. However, any DOM nodes that are wired are still "active" in that they still fire their interaction events (=click=, =mouseover=, etc.) when the widget is busy or disabled. If the widget doesn't explicitly check the busy or enabled state properties in its event handlers, than those DOM nodes will still be interactive even when the widget is supposed to be busy or disabled.
	
	So, the solution is to have DOM event bindings not call the handler when the widget is either busy or disabled. However, given that there may be some edge cases where the widget wants DOM interactivity even when it is busy or disabled, there should be means of overriding the default behavior. 
	
	Sample Updated Interface
		The interface for =eventBindings= will be the same if the widget wants to prevent event handlers from being called when the widget is busy or disabled.  But if it needs to override that behavior...
		
		...
		eventBindings:{
			'#myNode:Click':function() { }, // default case
			'#allowBusy:Click':{
				handler:function() {  },
				fireIf:'busyInherited'  // only fire when busy
			}
		}
		...
		
		The value passed to =fireIf= is a property derivation that determines when the handler will be fired. It could be a property condition or just a derivation in which we would look at the truthiness or falsyness of it.  The default value is ='!busyInherited && enabledInherited'=.
		
	Sample Updated Implementation
		The implementation of =eventBindings= (for DOM nodes only) should include a following check to determine if the handler should be called...
		
		...
		if (m.isMet(_binding.alwaysFire || '!busyInherited && enabledInherited')) {
			// call handler
		}
		...
